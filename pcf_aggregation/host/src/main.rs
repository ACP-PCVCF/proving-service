// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{GUEST_PCF_CALCULATION_ELF, GUEST_PCF_CALCULATION_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt, InnerReceipt};
use serde::{Deserialize, Serialize};
use std::fs;
use std::error::Error;
use std::time::Instant; 
use uuid::Uuid; 
use csv::Writer;

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
pub struct GuestMetrics {
    pub start_cycles: u64,
    pub end_cycles: u64,
    pub risc_v_cycles: u64,
}

#[derive(Serialize)]
pub struct HostMetrics {
    proving_time: u64, // in milliseconds
    inputs_size: u64,
    proof_size: u64,
    #[cfg(target_os = "linux")] // Conditionally compile the field itself
    cpu_cyclus_host: u64,
    #[cfg(not(target_os = "linux"))] 
    cpu_cyclus_host: Option<u64>, 
    guest_cycles: u64,
    prove_depth: u64,
    overhead_1: f64,
    efficiency: f64,
}

impl HostMetrics {
    pub fn new() -> Self {
        Self {
            proving_time: 0,
            inputs_size: 0,
            proof_size: 0,
            #[cfg(target_os = "linux")]
            cpu_cyclus_host: 0,
            #[cfg(not(target_os = "linux"))]
            cpu_cyclus_host: None, // Initialize Option to None
            guest_cycles: 0,
            prove_depth: 0,
            overhead_1: 0.0,
            efficiency: 0.0,
        }
    }

    pub fn set_proving_time_ms(&mut self, duration_ms: u64) {
        self.proving_time = duration_ms;
    }

    pub fn proof_size(&mut self, receipt: &Receipt) {
        self.proof_size = bincode::serialized_size(receipt).unwrap_or(0) as u64;
    }

    pub fn input_size<T: Serialize>(&mut self, input: &T) { // Corrected: pass the actual input
        self.inputs_size = bincode::serialized_size(input).unwrap_or(0) as u64;
    }

    #[cfg(target_os = "linux")]
    pub fn host_cpu_cycles<F>(&mut self, f: F) -> Result<(), Box<dyn Error>>
    where
        F: FnOnce(),
    {
        // Ensure perf_event::Builder is in scope
        use perf_event::Builder;
        let mut counter = Builder::new().build_hardware(perf_event::events::Hardware::CPU_CYCLES)?;
        counter.enable()?;
        f();
        counter.disable()?;
        self.cpu_cyclus_host = counter.read()?;
        Ok(())
    }

    // Method to set prove_depth (segment count)
    pub fn set_prove_depth(&mut self, receipt: &Receipt) {
        match &receipt.inner {
            InnerReceipt::Composite(composite_seal) => {
                self.prove_depth = composite_seal.segments.len() as u64;
            }
            InnerReceipt::Groth16(_) => {
                self.prove_depth = 1; // Typically 1 segment for a non-composite Groth16 proof
            }
            // InnerReceipt::Succinct(_) => {
            //     self.prove_depth = 1;
            // }
            _ => {
                eprintln!("WARN: Unhandled InnerReceipt variant for prove_depth extraction. Prove depth set to 1.");
                self.prove_depth = 1 // Or 1, depending on desired default
            }
        }
    }

    pub fn metrics_write_csv(&self) -> Result<(), Box<dyn Error>> {
        let mut wtr = Writer::from_writer(vec![]);
        wtr.serialize(self)?;
        let data = String::from_utf8(wtr.into_inner()?)?;
        println!("{}", data);
        Ok(())
    }

    pub fn efficiency(&mut self, g_metrics: &GuestMetrics) {
        #[cfg(target_os = "linux")]
        if g_metrics.risc_v_cycles > 0 {
            self.efficiency = self.cpu_cyclus_host as f64 / g_metrics.risc_v_cycles as f64;
        } else {
            self.efficiency = 0.0;
        }
        #[cfg(not(target_os = "linux"))]
        if g_metrics.risc_v_cycles > 0 && self.cpu_cyclus_host.is_some() {
             self.efficiency = 0.0;
        } else {
            self.efficiency = 0.0;
        }
    }

    pub fn overhead_1(&mut self) {
        if self.prove_depth > 0 {
            self.overhead_1 = self.proving_time as f64 / self.prove_depth as f64;
        } else {
            self.overhead_1 = 0.0;
        }
    }

    pub fn guest_cycles(&mut self, g_metrics: &GuestMetrics) {
        self.guest_cycles = g_metrics.risc_v_cycles;
    }
}


fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let run_id = Uuid::new_v4().to_string(); // Corrected: Use imported Uuid
    //let mut host_metrics = HostMetrics::new(format!("{}_host_metrics.csv", run_id), run_id.clone());
    let mut host_metrics = HostMetrics::new();

    #[derive(Serialize, Deserialize)]
    pub struct StoredData {
        pub receipt: Receipt,
        pub previous_id: [u32; 8],
    }

    let json =
        std::fs::read_to_string("host/src/pcf_supply_proof.json").expect("Konnte JSON nicht laden");

    let stored_data: StoredData = serde_json::from_str(&json).expect("Konnte JSON nicht parsen");

    
    let previous_id = stored_data.previous_id;
    let previous_receipt = stored_data.receipt;

    // For example:
    let input: u32 = 345;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .write(&previous_id)
        .unwrap()
        .write(&previous_receipt)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    let prove_start_time = Instant::now();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, GUEST_PCF_CALCULATION_ELF).unwrap();

    let prove_duration = prove_start_time.elapsed();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    let (pcf_total, guest_metrics_from_journal): (u32, GuestMetrics) = receipt.journal.decode().unwrap();

    println!("{}", pcf_total);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(GUEST_PCF_CALCULATION_ID).unwrap();


    host_metrics.set_proving_time_ms((prove_duration.as_secs_f64() * 1000.0) as u64);
    //host_metrics.input_size(&combined_input); // Pass the actual input object
    host_metrics.proof_size(&receipt); // Pass the receipt object

    host_metrics.guest_cycles(&guest_metrics_from_journal);

    #[cfg(target_os = "linux")]
    {

        if let Err(e) = host_metrics.host_cpu_cycles(|| { }) {
            eprintln!("Failed to get host CPU cycles: {}", e);
        }
    }

    host_metrics.set_prove_depth(&receipt); // Calculate and set prove_depth
    host_metrics.overhead_1(); // Call with no arguments
    host_metrics.efficiency(&guest_metrics_from_journal); // Call with GuestMetrics

    if let Err(e) = host_metrics.metrics_write_csv() {
        eprintln!("Fehler beim Schreiben der CSV-Datei: {}", e);
    }
}
