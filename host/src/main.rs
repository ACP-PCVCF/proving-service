// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    GUEST_PROOFING_LOGIC_ELF, GUEST_PROOFING_LOGIC_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt,  ReceiptKind};
use serde::{Deserialize, Serialize};
use rdkafka::consumer::{Consumer, StreamConsumer};
use rdkafka::producer::{FutureProducer, FutureRecord};
use rdkafka::config::ClientConfig;
use tokio::time::Duration;
use rdkafka::message::Message;
use risc0_zkvm::guest::env; 
use serde_json::json;
use log::info; 
use serde_json::Value;
use::std::collections::HashMap; 



use base64::{engine::general_purpose, Engine as _};

use axum::{
    routing::get,
    routing::post, 
    Router,
    Json
};

    #[derive(Serialize)]
    struct ProofResponse {
    proof_receipt: String,
    journal_output: f32,
    image_id: String,
}


    #[derive(Serialize, Deserialize)]
    pub struct StoredData {
        pub receipt: Receipt,
        pub previous_id: [u32; 8],
    }


    #[derive(Deserialize, Serialize)]
struct ShipmentInfo {
    activity_data_json: String,
    activity_signature: String,
    activity_public_key_pem: String,
}

#[derive(Deserialize, Serialize)]
struct Shipment {
    shipment_id: String,
    info: ShipmentInfo,
}




#[derive(Debug, Serialize, Deserialize)]
pub struct ProductFootprintRoot {
    pub productFootprint: ProductFootprint,
    pub tocData: Vec<TocData>,
    pub hocData: Vec<HocData>,
    pub signedSensorData: Option<serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ProductFootprint {
    pub id: String,
    pub specVersion: String,
    pub version: i32,
    pub created: String,
    pub status: String,
    pub companyName: String,
    pub companyIds: Vec<String>,
    pub productDescription: String,
    pub productIds: Vec<String>,
    pub productCategoryCpc: i32,
    pub productNameCompany: String,
    pub pcf: Option<serde_json::Value>,
    pub comment: String,
    pub extensions: Vec<Extension>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Extension {
    pub specVersion: String,
    pub dataSchema: String,
    pub data: ExtensionData,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ExtensionData {
    pub mass: f64,
    pub shipmentId: String,
    pub tces: Vec<Tce>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Tce {
    pub tceId: String,
    pub prevTceIds: Vec<String>,
    pub hocId: Option<String>,
    pub tocId: Option<String>,
    pub shipmentId: String,
    pub mass: f64,
    pub co2eWTW: Option<serde_json::Value>,
    pub co2eTTW: Option<serde_json::Value>,
    pub transportActivity: Option<serde_json::Value>,
    pub distance: Option<Distance>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Distance {
    pub actual: f64,
    pub gcd: Option<serde_json::Value>,
    pub sfd: Option<serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TocData {
    pub tocId: String,
    pub certifications: Vec<String>,
    pub description: String,
    pub mode: String,
    pub loadFactor: String,
    pub emptyDistanceFactor: String,
    pub temperatureControl: String,
    pub truckLoadingSequence: String,
    pub airShippingOption: Option<serde_json::Value>,
    pub flightLength: Option<serde_json::Value>,
    pub energyCarriers: Vec<EnergyCarrier>,
    pub co2eIntensityWTW: String,
    pub co2eIntensityTTW: String,
    pub transportActivityUnit: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct HocData {
    pub hocId: String,
    pub passhubType: String,
    pub energyCarriers: Vec<EnergyCarrier>,
    pub co2eIntensityWTW: String,
    pub co2eIntensityTTW: String,
    pub hubActivityUnit: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EnergyCarrier {
    pub energyCarrier: String,
    pub distributionEfficiency: String,
    pub energyDensity: String,
    pub unit: String,
}



async fn process_payload(payload_str: &str) -> Option<ProofResponse> {
    println!("Rohdaten der Nachricht: {}", payload_str);
    // Versuch direkt zu parsen (raw JSON)
    if let Ok(proof_response) = try_handle_raw_json(payload_str).await {
        return Some(proof_response);
    }

    // Falls das fehlschlägt, versuche es als stringifizierten JSON-String zu entpacken
    let inner_json_str: String = match serde_json::from_str(payload_str) {
        Ok(s) => s,
        Err(e) => {
            eprintln!("Fehler beim Entpacken des JSON-Strings: {}", e);
            return None;
        }
    };

    try_handle_raw_json(&inner_json_str).await.ok()
}

async fn try_handle_raw_json(shipments_json: &str) -> Result<ProofResponse, ()> {
    match handle_kafka_message(shipments_json).await {
        Some(resp) => Ok(resp),
        None => Err(()),
    }
}

#[tokio::main]
async fn main() {
    let brokers = "localhost:9092";
    env_logger::init();

    let consumer: StreamConsumer = ClientConfig::new()
        .set("bootstrap.servers", brokers)
        .set("group.id", "risc0-pcf-kafka-group")
        .set("enable.auto.commit", "true")
        .create()
        .expect("Consumer creation failed");

    consumer.subscribe(&["shipments"]).unwrap();

    let producer: FutureProducer = ClientConfig::new()
        .set("bootstrap.servers", brokers)
        .create()
        .expect("Producer creation failed");

 loop {
    match consumer.recv().await {
        Ok(message) => {
            match message.payload_view::<str>() {
                Some(Ok(payload_str)) => {
                    if let Some(proof_response) = process_payload(payload_str).await {
                        let result_json = serde_json::to_string(&proof_response)
                            .expect("Failed to serialize proof_response");
                        let record = FutureRecord::to("pcf-results")
                            .payload(&result_json)
                            .key("some-key");
                        let _ = producer.send(record, Duration::from_secs(10)).await;
                    } else {
                        info!("Ungültige Nachricht wurde ignoriert.");
                    }
                }
                Some(Err(e)) => eprintln!("Payload UTF-8 error: {}", e),
                None => eprintln!("No payload"),
            }
        }
        Err(e) => eprintln!("Kafka error receiving message: {:?}", e),
    }
}
}
   /* match consumer.recv().await {
        Ok(message) => {
            match message.payload_view::<str>() {
                 Some(std::str::from_utf8(bytes)) => {
                    let proof_response = handle_kafka_message(payload).await;

                    let result_json = serde_json::to_string(&proof_response)
                        .expect("Failed to serialize proof_response");

                    let _ = producer.send(
                        FutureRecord::to("pcf-results")
                            .payload(&result_json),
                        Duration::from_secs(0),
                    ).await;
                }
                  _ => {
                    eprintln!("Error decoding payload");
                }
            }
        }
        Err(e) => eprintln!("Kafka error receiving message: {:?}", e),
    }
}
} */ 

 

async fn handle_kafka_message(shipments_json: &str) -> Option<ProofResponse> {
    println!("Rohdaten der Nachricht: {}", &shipments_json);

    // Erwartet ein JSON-Array: Vec<Shipment>
    let shipments: ProductFootprintRoot = match serde_json::from_str(shipments_json) {
        Ok(s) => s,
        Err(e) => {
            eprintln!("Ungültige Nachricht ignoriert (JSON Fehler): {}", e);
            return None;
        }
    };

    let env = match ExecutorEnv::builder().write(&shipments).and_then(|b| b.build()) {
        Ok(env) => env,
        Err(e) => {
            eprintln!("Fehler beim Erstellen der ExecutorEnv: {}", e);
            return None;
        }
    };

    let prover = default_prover();
    let prove_info = match prover.prove(env, GUEST_PROOFING_LOGIC_ELF) {
        Ok(info) => info,
        Err(e) => {
            eprintln!("Fehler beim Prove: {}", e);
            return None;
        }
    };

    let receipt = prove_info.receipt;

    let journal_output: f32 = match receipt.journal.decode() {
        Ok(val) => val,
        Err(e) => {
            eprintln!("Fehler beim Dekodieren des Journals: {}", e);
            return None;
        }
    };

    if let Err(e) = receipt.verify(GUEST_PROOFING_LOGIC_ID) {
        eprintln!("Receipt Verification failed: {}", e);
        return None;
    }

    let receipt_bytes = match bincode::serialize(&receipt) {
        Ok(bytes) => bytes,
        Err(e) => {
            eprintln!("Fehler beim Serialisieren des Receipts: {}", e);
            return None;
        }
    };

    let encoded_receipt = general_purpose::STANDARD.encode(receipt_bytes);

    env::log("Handed over response ...");

    Some(ProofResponse {
        proof_receipt: encoded_receipt,
        journal_output,  // TODO, kann weg
        image_id: format!("{:?}", GUEST_PROOFING_LOGIC_ID),
    })
}


    /*let env = ExecutorEnv::builder()
        .write(&shipments)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    let prove_info = prover.prove(env, GUEST_PROOFING_LOGIC_ELF).unwrap();
    let receipt = prove_info.receipt;

    let journal_output: f32 = receipt.journal.decode().unwrap();
    receipt.verify(GUEST_PROOFING_LOGIC_ID).unwrap();

    let receipt_bytes = bincode::serialize(&receipt).unwrap();
    let encoded_receipt = general_purpose::STANDARD.encode(receipt_bytes);

    env::log("Handed over response ..."); 

    ProofResponse {
        proof_receipt: encoded_receipt,
        journal_output,
        image_id: format!("{:?}", GUEST_PROOFING_LOGIC_ID),
    }


    */




async fn prove_plain_ad(Json(shipments): Json<Vec<Shipment>>) -> Json<ProofResponse> {
    // Initialize tracing (optional; remove if you initialize globally)
    let _ = tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .try_init();

    let env = ExecutorEnv::builder()
        .write(&shipments)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    let prove_info = prover.prove(env, GUEST_PROOFING_LOGIC_ELF).unwrap();
    let receipt = prove_info.receipt;

    // Decode output from receipt journal
    let journal_output: f32 = receipt.journal.decode().unwrap();

    // Verify the receipt (optional here, but shows it works)
    receipt.verify(GUEST_PROOFING_LOGIC_ID).unwrap();

    // Serialize receipt (as base64-encoded bytes)
    let receipt_bytes = bincode::serialize(&receipt).unwrap();
    let encoded_receipt = general_purpose::STANDARD.encode(receipt_bytes);

    Json(ProofResponse {
        proof_receipt: encoded_receipt,
        journal_output,
        image_id: format!("{:?}", GUEST_PROOFING_LOGIC_ID),
    })
}




#[cfg(test)]
mod tests {
    use super::handle_kafka_message;
    use crate::{ProofResponse, Shipment, ShipmentInfo};
    use tokio;

    #[tokio::test]
    async fn smoke_test_with_realistic_shipments_json() {
        // 1) The exact JSON array you provided, as a single string literal
        let shipments_json = r#"{
  "productFootprint": {
    "id": "d7383bf3-90e9-4c95-a421-633b979acfe7",
    "specVersion": "2.0.0",
    "version": 0,
    "created": "2025-06-01T00:04:06.251704",
    "status": "Active",
    "companyName": "Amazing Company 1",
    "companyIds": [
      "urn:epcidsgln:70f8760c-64ec-4eb6-9de1-3fb659c18716"
    ],
    "productDescription": "Logistics emissions related to shipment with ID SHIP_71a3dd36-db87-403e-af43-8ee263593d1d",
    "productIds": [
      "urn:pathfinder:product:customcode:vendor-assigned:e40642c5-fbbf-45f9-9e4d-309361dd8350"
    ],
    "productCategoryCpc": 5839,
    "productNameCompany": "Shipment with ID SHIP_71a3dd36-db87-403e-af43-8ee263593d1d",
    "pcf": null,
    "comment": "",
    "extensions": [
      {
        "specVersion": "2.0.0",
        "dataSchema": "https://api.ileap.sine.dev/shipment-footprint.json",
        "data": {
          "mass": 1677.5024610506578,
          "shipmentId": "SHIP_71a3dd36-db87-403e-af43-8ee263593d1d",
          "tces": [
            {
              "tceId": "8f3c12fa-9ea1-48bf-a707-44c452942d0e",
              "prevTceIds": [],
              "hocId": "100",
              "tocId": null,
              "shipmentId": "SHIP_71a3dd36-db87-403e-af43-8ee263593d1d",
              "mass": 1677.5024610506578,
              "co2eWTW": null,
              "co2eTTW": null,
              "transportActivity": null,
              "distance": null
            },
            {
              "tceId": "b154acb2-eced-40a7-b0e7-7302cd8dae80",
              "prevTceIds": [
                "8f3c12fa-9ea1-48bf-a707-44c452942d0e"
              ],
              "hocId": null,
              "tocId": "200",
              "shipmentId": "SHIP_71a3dd36-db87-403e-af43-8ee263593d1d",
              "mass": 1677.5024610506578,
              "co2eWTW": null,
              "co2eTTW": null,
              "transportActivity": null,
              "distance": {
                "actual": 61.62903174862354,
                "gcd": null,
                "sfd": null
              }
            },
            {
              "tceId": "2d4f1c6a-f787-4130-bc65-d9afdd88fdbd",
              "prevTceIds": [
                "8f3c12fa-9ea1-48bf-a707-44c452942d0e",
                "b154acb2-eced-40a7-b0e7-7302cd8dae80"
              ],
              "hocId": "101",
              "tocId": null,
              "shipmentId": "SHIP_71a3dd36-db87-403e-af43-8ee263593d1d",
              "mass": 1677.5024610506578,
              "co2eWTW": null,
              "co2eTTW": null,
              "transportActivity": null,
              "distance": null
            }
          ]
        }
      }
    ]
  },
  "tocData": [
    {
      "tocId": "200",
      "certifications": [
        "ISO_14001",
        "ECO_TRANSIT_CERT"
      ],
      "description": "Standard Diesel Truck - Long Haul",
      "mode": "Road",
      "loadFactor": "0.80",
      "emptyDistanceFactor": "0.10",
      "temperatureControl": "Ambient",
      "truckLoadingSequence": "LIFO",
      "airShippingOption": null,
      "flightLength": null,
      "energyCarriers": [
        {
          "energyCarrier": "Diesel",
          "distributionEfficiency": "0.99",
          "energyDensity": "10.7 kWh/L",
          "unit": "L"
        }
      ],
      "co2eIntensityWTW": "85 gCO2e/tkm",
      "co2eIntensityTTW": "75 gCO2e/tkm",
      "transportActivityUnit": "tkm"
    }
  ],
  "hocData": [
    {
      "hocId": "100",
      "passhubType": "Charging Hub",
      "energyCarriers": [
        {
          "energyCarrier": "Electricity",
          "distributionEfficiency": "0.98",
          "energyDensity": "1 kWh/unit",
          "unit": "kWh"
        }
      ],
      "co2eIntensityWTW": "25 gCO2e/MJ",
      "co2eIntensityTTW": "0 gCO2e/MJ",
      "hubActivityUnit": "kWh delivered"
    },
    {
      "hocId": "101",
      "passhubType": "Refuelling Hub",
      "energyCarriers": [
        {
          "energyCarrier": "Hydrogen",
          "distributionEfficiency": "0.90",
          "energyDensity": "33.3 kWh/kg",
          "unit": "kg"
        },
        {
          "energyCarrier": "Diesel",
          "distributionEfficiency": "0.99",
          "energyDensity": "10.7 kWh/L",
          "unit": "L"
        }
      ],
      "co2eIntensityWTW": "70 gCO2e/MJ",
      "co2eIntensityTTW": "0 gCO2e/MJ",
      "hubActivityUnit": "kg dispensed"
    }
  ],
  "signedSensorData": null
}"#  ; 




/* r#"
        [
          {
            "shipment_id": "SHIP_3a9eb761-c4b3-40c1-8658-5652211d7367",
            "info": {
              "activity_data_json": "{\"arrivalAt\":\"2025-05-08T03:05:21Z\",\"co2_factor_ttw_per_tkm\":\"0.095\",\"co2eTTW\":\"559.625\",\"co2eWTW\":\"654.271\",\"departureAt\":\"2025-05-07T21:34:27Z\",\"destination\":{\"city\":\"München\",\"countryCode\":\"DE\",\"locationName\":\"München\",\"postalCode\":\"67805\",\"type\":\"PhysicalLocation\"},\"distance\":{\"dataSource\":\"Simulated\",\"unit\":\"km\",\"value\":\"417.94\"},\"hocId\":\"HOC_02454dc6-0cd3-435e-8456-e3edeba82baf\",\"incoterms\":\"FCA\",\"mass\":\"14166.32\",\"origin\":{\"city\":\"Leipzig\",\"countryCode\":\"DE\",\"locationName\":\"Leipzig\",\"postalCode\":\"52963\",\"type\":\"PhysicalLocation\"},\"packagingOrTrEqAmount\":\"9.17\",\"packagingOrTrEqType\":\"Bulk\",\"shipmentId\":\"SHIP_1dc6b75e-74d1-41f0-9b21-737b558bbb5f\",\"tceId\":\"TCE_5db5deda-d1d8-4614-a671-6185cc0e326e\",\"transportActivity\":\"5920.722\",\"wtw_multiplier\":\"1.169\"}",
              "activity_signature": "Uzp6gzcTUG0LuU9CWysz8TIsmVDQiS1+HBJrm9eiSCpK4luMgmAfhWkxkK33mM+bojsdgOcKuladAee6+GFQgrTCeoSsqtxpfsgVp31u8f0MxqYv7jqd59ofR737f4anlVp5pzLpj2UFrK+40TnLdIckcOtOxegf5NzztRSEV/bY26/iku0/DRqenqbPifEj9AsVbdms+C50bXMchn/kMQKmybOZArwy0u29X+97PhycFOIC94pLCv2z+0oL7DKEY/TdQDCToZdBDxLZrKduvyriKXeEOsoOS359ElWwIdXEta4w0mooEe4SMXJ2IIarNNS45rHjLYIuF7PrLhRzbA==",
              "activity_public_key_pem": "-----BEGIN RSA PUBLIC KEY-----\nMIIBCgKCAQEArctYpdG5jXRW0FDAFX0WSPOpmJ7vXkdjcTKGt5u+3ndmBULKK00l\nAMRoz+zcYaAReE6TC2U0h8/+Vg71JNxu2JhBVDZ3iMlvZSkKb9SDWSN8abkP5Sx+\nZ25xYCnU+23bBtpRRs3uxw4kCbY52nGFteRhxDO0iLeL15cs+SEMov36CauDwPmS\nMJNvoBEFZCR4OmvNCmrAf7ToYr6MaLRUv5Th3ygtACtgcZI5eyK9ti/bb2yI6ani\nGUIJSfb2PN0kB75PN6YssPrzhNAmZVCHyEQ73Z+etQXbx22oNK+lNpjr3Pm+xf5h\nnPdyJTrrAw2AJZRncM7SnVK+9iVRv+FF0wIDAQAB\n-----END RSA PUBLIC KEY-----"
            }
          },
          {
            "shipment_id": "SHIP_44952dce-316f-4eee-9c68-3dcf6d8a1bbe",
            "info": {
              "activity_data_json": "{\"arrivalAt\":\"2025-05-08T03:53:32Z\",\"co2_factor_ttw_per_tkm\":\"0.100\",\"co2eTTW\":\"591.140\",\"co2eWTW\":\"713.147\",\"departureAt\":\"2025-05-07T21:37:53Z\",\"destination\":{\"city\":\"Mannheim\",\"countryCode\":\"DE\",\"locationName\":\"Mannheim\",\"postalCode\":\"99952\",\"type\":\"PhysicalLocation\"},\"distance\":{\"dataSource\":\"Simulated\",\"unit\":\"km\",\"value\":\"417.94\"},\"incoterms\":\"FAS\",\"mass\":\"14166.32\",\"noxTTW\":\"11.8609\",\"origin\":{\"city\":\"Berlin\",\"countryCode\":\"DE\",\"locationName\":\"Berlin\",\"postalCode\":\"96154\",\"type\":\"PhysicalLocation\"},\"shipmentId\":\"SHIP_1dc6b75e-74d1-41f0-9b21-737b558bbb5f\",\"tceId\":\"TCE_cfdcee37-8171-4032-956c-2b5f3825a7a5\",\"tocId\":\"TOC_1d16c82f-008a-47c0-8641-d3a725520877\",\"transportActivity\":\"5920.722\",\"wtw_multiplier\":\"1.206\"}",
              "activity_signature": "ofEbfExklDhEwTrTLzJAOIBwG4NkVo+kWeHE0lnmCOmI2XLjec62UOCPhNeGjrWESlFDG1HdGhpNgglDVr63luPPDR7+Slc1vDxSWHLar79cD1v16h+zD42DKBmdyDhGG9Yxmkhu5bY3qQqs0UCaHkdpxb5VjtGBR+/j/w/WGqguDgW7rwmE4u88wOsVNFZ4oLuDlzFAt7Hch0O2/FDPN1Y7ct5AkNLxOso7af8twHdDgYpWxobi7X/1vW7Ry/mwsL0uOEirJJgd1N+Tc//anrh7fs/4F/6aNY/87NNY+mc/aGHUfYsZHKwzBfG8viVKvFVOa2egYJYuRkB+0shYwQ==",
              "activity_public_key_pem": "-----BEGIN RSA PUBLIC KEY-----\nMIIBCgKCAQEArctYpdG5jXRW0FDAFX0WSPOpmJ7vXkdjcTKGt5u+3ndmBULKK00l\nAMRoz+zcYaAReE6TC2U0h8/+Vg71JNxu2JhBVDZ3iMlvZSkKb9SDWSN8abkP5Sx+\nZ25xYCnU+23bBtpRRs3uxw4kCbY52nGFteRhxDO0iLeL15cs+SEMov36CauDwPmS\nMJNvoBEFZCR4OmvNCmrAf7ToYr6MaLRUv5Th3ygtACtgcZI5eyK9ti/bb2yI6ani\nGUIJSfb2PN0kB75PN6YssPrzhNAmZVCHyEQ73Z+etQXbx22oNK+lNpjr3Pm+xf5h\nnPdyJTrrAw2AJZRncM7SnVK+9iVRv+FF0wIDAQAB\n-----END RSA PUBLIC KEY-----"
            }
          }
        ]
        "#;  */ 


        // Call kafka handler
        let resp: ProofResponse = handle_kafka_message(shipments_json).await.expect("kafka_handler_failed");

        // check outcomes 
        assert!(!resp.proof_receipt.is_empty(), "receipt must be generated");
        assert!(resp.journal_output.is_finite(), "journal_output must be numeric");
        assert!(!resp.image_id.is_empty(), "image_id must be present");
    }
}
